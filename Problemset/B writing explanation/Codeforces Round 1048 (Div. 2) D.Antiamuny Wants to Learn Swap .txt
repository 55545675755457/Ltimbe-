本题的关键在于意识到什么情况下用操作2会有利：
显然，当遇到321这种类型的时候有利，因为1要向左走2，3要向右走2
对于4132，4要和1换完再让2和4换
总结：只要有一个数要向右走2格及以上，一个数要向左走2格及以上，且两边路径有交叉，就输出NO
注意到区间变大原本NO的还是NO，因为原本的路径交叉肯定还是交叉着的，至于长度>1的要求，如果原本满足但边上（不妨假设是右边）加了一个新数后不满足，那必然是有一个长度为2的路径变成了1，这要求新加的跑到左边去，又产生了新的交叉
于是立刻想到双指针滑动区间，一个指针i从左往右遍历，一个j指示区间左为i时区间右的最小值
判断j往右走是否从YES到NO，只需要判断新加进来的数是否与其他数产生交叉，那只需要比前面这个区间的次大值更小即可
只需要处理每一个区间的次大值，这可以用线段树解决
总体时间复杂度nlogn，看数据规模觉得应该没问题